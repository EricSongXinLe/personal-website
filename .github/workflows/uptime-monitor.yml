name: Uptime Monitor

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  health-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check backoff state
        id: backoff
        uses: actions/github-script@v7
        with:
          script: |
            const title = '[monitor] Site health check failed';
            const label = 'monitoring';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            function parseState(issueBody) {
              const match = (issueBody || '').match(/<!-- monitor-state:(.+) -->/);
              if (!match) return { consecutiveFailures: 0, nextCheckAt: null };
              try {
                const parsed = JSON.parse(match[1]);
                return {
                  consecutiveFailures: Number(parsed.consecutiveFailures || 0),
                  nextCheckAt: parsed.nextCheckAt || null,
                };
              } catch (error) {
                return { consecutiveFailures: 0, nextCheckAt: null };
              }
            }

            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: label,
            });

            const incident = issues.find((issue) => issue.title === title);
            if (!incident) {
              core.setOutput('skip', 'false');
              core.setOutput('issue_number', '');
              core.info('No open incident issue. Will run health check.');
              return;
            }

            const state = parseState(incident.body || '');
            const now = Date.now();
            const nextCheckAtMs = state.nextCheckAt ? Date.parse(state.nextCheckAt) : NaN;
            const shouldSkip = Number.isFinite(nextCheckAtMs) && now < nextCheckAtMs;

            core.setOutput('skip', shouldSkip ? 'true' : 'false');
            core.setOutput('issue_number', String(incident.number));
            core.setOutput('consecutive_failures', String(state.consecutiveFailures || 0));

            if (shouldSkip) {
              core.info(
                `Backoff active. Consecutive failures=${state.consecutiveFailures || 0}, next check at ${state.nextCheckAt}.`
              );
              return;
            }

            core.info('Backoff window elapsed. Will run health check.');

      - name: Checkout
        if: steps.backoff.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Setup Node
        if: steps.backoff.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Skip run due to backoff window
        if: steps.backoff.outputs.skip == 'true'
        run: |
          echo "Skipping health check due to active backoff window."
          echo "Open issue: #${{ steps.backoff.outputs.issue_number }}"
          echo "Consecutive failures: ${{ steps.backoff.outputs.consecutive_failures }}"

      - name: Run health checks
        if: steps.backoff.outputs.skip != 'true'
        env:
          SITE_URL: ${{ secrets.SITE_URL }}
          EXPECTED_TITLE: ${{ secrets.EXPECTED_TITLE }}
          HEALTHCHECK_TIMEOUT_MS: "8000"
          HEALTHCHECK_MAX_RESPONSE_MS: "3000"
        run: npm run healthcheck

      - name: Create or update incident on failure
        if: failure() && steps.backoff.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const title = '[monitor] Site health check failed';
            const label = 'monitoring';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const nowIso = new Date().toISOString();

            function parseState(issueBody) {
              const match = (issueBody || '').match(/<!-- monitor-state:(.+) -->/);
              if (!match) return { consecutiveFailures: 0, nextCheckAt: null };
              try {
                const parsed = JSON.parse(match[1]);
                return {
                  consecutiveFailures: Number(parsed.consecutiveFailures || 0),
                  nextCheckAt: parsed.nextCheckAt || null,
                };
              } catch (error) {
                return { consecutiveFailures: 0, nextCheckAt: null };
              }
            }

            function computeDelayMinutes(consecutiveFailures) {
              if (consecutiveFailures <= 1) return 15;
              if (consecutiveFailures === 2) return 30;
              if (consecutiveFailures === 3) return 60;
              if (consecutiveFailures === 4) return 120;
              if (consecutiveFailures === 5) return 240;
              return 480;
            }

            function buildBody(state) {
              const marker = `<!-- monitor-state:${JSON.stringify(state)} -->`;
              return [
                'Automated health check failed.',
                '',
                `- Consecutive failures: ${state.consecutiveFailures}`,
                `- Last failure time (UTC): ${nowIso}`,
                `- Next full check not before (UTC): ${state.nextCheckAt}`,
                `- Workflow run: ${runUrl}`,
                '',
                'The workflow still triggers every 15 minutes, but checks are skipped during backoff windows.',
                '',
                marker,
              ].join('\n');
            }

            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: label,
            });

            const existing = issues.find((issue) => issue.title === title);
            const previousState = existing ? parseState(existing.body || '') : { consecutiveFailures: 0, nextCheckAt: null };
            const consecutiveFailures = previousState.consecutiveFailures + 1;
            const delayMinutes = computeDelayMinutes(consecutiveFailures);
            const nextCheckAt = new Date(Date.now() + delayMinutes * 60 * 1000).toISOString();

            const state = { consecutiveFailures, nextCheckAt };
            const body = buildBody(state);

            if (existing) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: existing.number,
                body,
              });
              core.info(
                `Updated incident #${existing.number}. failures=${consecutiveFailures}, delay=${delayMinutes}m`
              );
              return;
            }

            const { data: created } = await github.rest.issues.create({
              owner,
              repo,
              title,
              labels: [label],
              body,
            });

            core.info(`Created incident #${created.number}. failures=${consecutiveFailures}, delay=${delayMinutes}m`);

      - name: Close incident issue on recovery
        if: success() && steps.backoff.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const title = '[monitor] Site health check failed';
            const label = 'monitoring';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: label,
            });

            const activeIncident = issues.find((issue) => issue.title === title);
            if (!activeIncident) {
              core.info('No active incident issue found.');
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: activeIncident.number,
              body: `Recovered at ${new Date().toISOString()} UTC. Backoff state cleared.`,
            });

            await github.rest.issues.update({
              owner,
              repo,
              issue_number: activeIncident.number,
              state: 'closed',
            });
